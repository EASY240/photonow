The Problem: Screaming Frog sees the exact same MD5 hash for https://modernphototools.com/ and .../tools/prompt-generator because your server is returning the generic index.html shell for all these URLs. Since the JavaScript hasn't run yet in the crawler's view (or the initial HTML is identical), they look like duplicate pages.

The Solution: We need to:

Fix the React Component: Your PromptGeneratorPage.tsx is missing the SEO meta tags (it likely has Next.js style metadata export which doesn't work in Vite).

Implement Prerendering: Create a script that generates unique static HTML files for every route (Home, Tools, Prompt Generator) during the build process.

Here is the code to fix this.

Step 1: Fix SEO in PromptGeneratorPage.tsx
Your page component imports SEO but doesn't use it, causing the page to default to the site-wide title (making it a duplicate).

File: src/pages/PromptGeneratorPage.tsx

TypeScript

import React, { useMemo, useState, useEffect, useRef } from 'react';
import { Helmet } from 'react-helmet-async';
import { HelpCircle, ClipboardCopy } from 'lucide-react';
// ... existing imports
import SEO from '../components/ui/SEO'; // Ensure this is imported

// ... existing code ...

export default function PromptGeneratorPage() {
  // ... existing state logic ...

  return (
    <>
      {/* ADD THIS SEO BLOCK */}
      <SEO 
        title="AI Prompt Generator | Create Professional AI Art Prompts"
        description="Free AI Prompt Generator. Transform simple ideas into professional prompts for Midjourney, ChatGPT, and Stable Diffusion using proven frameworks (ICDF, RCREOC)."
        keywords={['AI prompt generator', 'prompt engineering', 'Midjourney prompts', 'ChatGPT prompts', 'ICDF framework']}
        canonicalUrl="https://modernphototools.com/tools/prompt-generator"
      />

      <div className="container mx-auto px-4 py-12 max-w-6xl">
        {/* ... existing JSX content ... */}
        <div className="text-center mb-8">
           {/* ... */}
        </div>
      </div>
    </>
  );
}
Step 2: Create a Dynamic Prerender Script
We need a script that finds all your tools and generates static HTML for them. This ensures Screaming Frog sees unique content (H1 tags, specific titles) for every URL.

Create File: scripts/prerender.js

JavaScript

const fs = require('node:fs');
const path = require('node:path');
const { fileURLToPath } = require('node:url');

const toAbsolute = (p) => path.resolve(__dirname, '..', p);

// Reuse the logic from your sitemap generator to parse data files
function parseDataFile(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf-8');
    const exportMatch = content.match(/export const (\w+):\s*\w+\[\]\s*=\s*(\[[\s\S]*?\]);/);
    if (exportMatch) {
      const [, , arrayContent] = exportMatch;
      let jsonContent = arrayContent
        .replace(/'/g, '"')
        .replace(/(\w+):/g, '"$1":')
        .replace(/,\s*}/g, '}')
        .replace(/,\s*]/g, ']');
      return JSON.parse(jsonContent);
    }
    return [];
  } catch (e) {
    console.warn(`Warning: Could not parse ${filePath}`);
    return [];
  }
}

async function prerender() {
  console.log('üöÄ Starting Prerendering...');

  const template = fs.readFileSync(toAbsolute('dist/index.html'), 'utf-8');
  const { render } = require(toAbsolute('dist/server/entry-server.js'));

  // 1. Define Static Routes
  const routesToPrerender = [
    '/',
    '/tools',
    '/blog',
    '/about',
    '/contact',
    '/privacy-policy',
    '/terms-of-use',
    '/dmca',
    '/tools/prompt-generator', // Explicitly add your problem page
    '/tools/watermark-remover' // Explicitly add the other problem page
  ];

  // 2. Add Dynamic Tool Routes
  const tools = parseDataFile(toAbsolute('src/data/tools.ts'));
  tools.forEach(tool => {
    if (tool.id) routesToPrerender.push(`/tools/${tool.id}`);
  });

  // 3. Add Dynamic Blog Routes
  // (Optional: Add logic to read markdown files if you want blog posts pre-rendered too)

  // Filter unique routes
  const uniqueRoutes = [...new Set(routesToPrerender)];

  console.log(`üìÑ Pre-rendering ${uniqueRoutes.length} pages...`);

  for (const url of uniqueRoutes) {
    try {
      const appHtml = await render(url);

      // Replace the root placeholder
      let html = template.replace(``, appHtml);
      
      // Inject unique title/meta (if your render function returns helmet context)
      // Assuming your entry-server.js handles helmetContext
      
      // Determine output path
      let filePath = `dist${url === '/' ? '/index.html' : url}`;
      
      // If path doesn't end in .html, make it a folder with index.html (better for SEO)
      if (!filePath.endsWith('.html')) {
          filePath = `${filePath}/index.html`;
      }

      const dir = path.dirname(toAbsolute(filePath));
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }

      fs.writeFileSync(toAbsolute(filePath), html);
      console.log(`‚úÖ Generated: ${filePath}`);
    } catch (e) {
      console.error(`‚ùå Failed to render ${url}:`, e);
    }
  }
}

prerender();
Step 3: Update Build Configuration
Ensure your entry-server.tsx (or .js) correctly extracts the Helmet data so the <title> tag actually changes in the static HTML.

File: src/entry-server.tsx (Verify this structure exists)

TypeScript

import React from 'react'
import ReactDOMServer from 'react-dom/server'
import { StaticRouter } from 'react-router-dom/server'
import { HelmetProvider } from 'react-helmet-async'
import App from './App'

export function render(url: string) {
  const helmetContext = {}
  
  const html = ReactDOMServer.renderToString(
    <React.StrictMode>
      <HelmetProvider context={helmetContext}>
        <StaticRouter location={url}>
          <App />
        </StaticRouter>
      </HelmetProvider>
    </React.StrictMode>
  )

  // IMPORTANT: You must return the helmet data to inject into the HTML template
  const { helmet } = helmetContext as any;
  
  // You might need to modify the prerender script to accept this object 
  // and replace in index.html if you have it.
  // For now, standard hydration usually grabs it, but for SEO, 
  // ensure your index.html has placeholders or use a transform in vite.
  
  return html
}